/*-------------------------------------------------------------------------------
 * Copyright (c) 2020 THALES GLOBAL SERVICES.
 *  
 *  This program and the accompanying materials are made available under the
 *   terms of the Eclipse Public License 2.0 which is available at
 *   http://www.eclipse.org/legal/epl-2.0
 *   
 *   SPDX-License-Identifier: EPL-2.0
 *   
 *   Contributors:
 *      Thales - initial API and implementation
 *-------------------------------------------------------------------------------*/
/*
 * generated by Xtext 2.18.0.M3
 */
package org.polarsys.capella.scenario.editor.dslscenario.ui.contentassist

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.Assignment
import org.polarsys.capella.scenario.editor.dslscenario.dsl.Model
import org.polarsys.capella.scenario.editor.dslscenario.dsl.SequenceMessage
import org.polarsys.capella.scenario.editor.dslscenario.dsl.Participant
import org.polarsys.capella.scenario.editor.helper.EmbeddedEditorInstanceHelper
import org.eclipse.xtext.Keyword
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.polarsys.capella.scenario.editor.dslscenario.dsl.Actor
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal.IReplacementTextApplier
import org.eclipse.jface.text.IDocument
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.jface.text.BadLocationException
import org.eclipse.xtext.util.Strings
import org.eclipse.xtext.ui.editor.contentassist.PrefixMatcher

/**
 * This class is used to display auto-complete proposals when pressing ctrl+space
 */
class DslProposalProvider extends AbstractDslProposalProvider {
	//@Inject DslscenarioProvider provider

	/*
	 * filter the proposed keywords based on the context in which we edit the text scenario;
	 * check the context of the Capella Diagram - layer (OA, SA, LA, PA), type of scenario (IS, ES FS)
	 */
	override completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
		ICompletionProposalAcceptor acceptor) {
		if (EmbeddedEditorInstanceHelper.checkValidKeyword(keyword.getValue())) {
			super.completeKeyword(keyword, contentAssistContext, acceptor)
		}
	}

	override completeActor_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("actor", context, acceptor, model, assignment)
	}

	override completeComponent_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("component", context, acceptor, model, assignment)
	}

	override completeConfigurationItem_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("configuration_item", context, acceptor, model, assignment)
	}

	override completeFunction_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("function", context, acceptor, model, assignment)
	}

	override completeActivity_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("activity", context, acceptor, model, assignment)
	}

	override completeEntity_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("entity", context, acceptor, model, assignment)
	}

	override completeRole_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		getExistingParticipants("role", context, acceptor, model, assignment)
	}

	def getExistingParticipants(String keyword, ContentAssistContext context, ICompletionProposalAcceptor acceptor,
		EObject model, Assignment assignment
	) {
		for (el : EmbeddedEditorInstanceHelper.getAvailableElements(keyword)) {
			
			var textApplier = new IReplacementTextApplier () {
				override apply(IDocument document, ConfigurableCompletionProposal proposal) throws BadLocationException {
					var participant = proposal.getAdditionalData("participant") as Participant
					participant.id = proposal.getAdditionalData("id") as String
					participant.name = "A"
					document.replace(proposal.getReplacementOffset(), proposal.getReplacementLength(), proposal.getReplacementString());
				}
			}

			var proposal = createCompletionProposal("\"" + EmbeddedEditorInstanceHelper.getName(el) + "\"",
					EmbeddedEditorInstanceHelper.getLabel(el), null, context) as ConfigurableCompletionProposal
			proposal.setTextApplier(textApplier)
			proposal.setAdditionalData("id", EmbeddedEditorInstanceHelper.getId(el))
			proposal.setAdditionalData("participant", context.currentModel)
			proposal.setAdditionalProposalInfo(EmbeddedEditorInstanceHelper.getId(el))
			proposal.setAutoInsertable(true);
			proposal.setSimpleLinkedMode(context.getViewer(), '\t', ' ');
			acceptor.accept(proposal);
		}
	}

	override completeSequenceMessage_Source(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		for (EObject el : variablesDefinedBefore2(model as Model)) {
			acceptor.accept(
				createCompletionProposal("\"" + (el as Actor).name + "\"", EmbeddedEditorInstanceHelper.getLabel(el),
					null, context))
		}
	}

	override completeSequenceMessage_Target(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		for (EObject el : variablesDefinedBefore3(model as SequenceMessage)) {
			acceptor.accept(
				createCompletionProposal("\"" + (el as Actor).name + "\"", EmbeddedEditorInstanceHelper.getLabel(el),
					null, context))
		}
	}

	def variablesDefinedBefore(Participant sc) {
		return sc

	}

	def variablesDefinedBefore2(Model m) {
		return m.participants

	}

	def variablesDefinedBefore3(SequenceMessage seq) {
		return (seq.eContainer as Model).participants
	}
}
